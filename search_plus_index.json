{"./":{"url":"./","title":"Introduction","keywords":"","body":"JavaJava Updated: 2018-05-22 16:51:04 离线阅读参考这个 菜鸟教程-Java教程 易百教程 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"SUMMARY","keywords":"","body":"SumarrySumarry Introduction SUMMARY Java基础 快速开始 类和对象 基本数据类型 变量类型 修饰符 运算符 循环结构 分支结构 数组 日期时间 方法 IO Scanner类 异常 面向对象 继承 重写与重载 多态 抽象类 封装 接口 包 tmp 高级教程 数据结构 集合框架 泛型 序列化 网络编程 发送邮件 多线程编程 JVM Collections Map Set Spring IntelliJ IDEA使用 Swagger2构建RESTful API tmp 使用Spring访问mysql 异常处理 模板引擎 注解 lib Lombok SLF4J tmp 测试题 "},"01-Java基础/":{"url":"01-Java基础/","title":"Java基础","keywords":"","body":"Java基础Table of contents介绍Java环境安装与配置MacOS安装JDKLinuxWindowsJDK, JRE, JVM开发工具笔记参考Java基础 Table of contents Java基础Table of contents介绍Java环境安装与配置MacOS安装JDKLinuxWindowsJDK, JRE, JVM开发工具笔记参考 介绍 Java环境安装与配置 Oracle官网 MacOS安装JDK Oracle官网 下载适用于macOS的JDK,(dmg) 安装dmg 安装完成会将系统默认的Java版本更新为对应的安装版本 终端验证java -version Linux 使用tar.gz包安装 Oracle官网 下载适用于Linux的二进制包 解压到想要安装的位置 配置环境变量 终端验证java -version Ubuntu使用apt-get安装 在Ubuntu默认的软件仓库中不包含Oracle官方提供的JDK, 我们可以添加第三方仓库来安装, 执行： sudo apt-get install python-software-properties sudo add-apt-repository ppa:webupd8team/java sudo apt-get update 使用apt-get安装Oracle的JDK # 安装需要安装的版本即可 sudo apt-get install oracle-java8-installer 安装完成会将系统默认的Java版本更新为对应的安装版本。 Windows 下载, 安装 配置环境变量 cmd执行命令java -version, javac -version JDK, JRE, JVM JDK : Java Development ToolKit JRE:Java Runtime Environment JVM：Java Virtual Machine JDK在包含JRE之外, 提供了开发Java应用的各种工具, 比如编译器和调试器。 JRE包括JVM和JAVA核心类库和支持文件, 是Java的运行平台, 所有的Java程序都要在JRE下才能运行。 JVM是JRE的一部分, Java虚拟机的主要工作是将Java字节码（通过Java程序编译得到）映射到本地的 CPU 的指令集或 OS 的系统调用。JVM回根据不同的操作系统使用不同的JVM映射规则, 从而使得Java平台与操作系统无关, 实现了跨平台的特性性。 在实际开发过程中, 我们首先编写Java代码, 然后通过JDK中的编译程序（javac）将Java文件编译成Java字节码, JRE加载和验证Java字节码, JVM解释字节码, 映射到CPU指令集或O的系统调用, 完成最终的程序功能。 开发工具 IntelliJ IDEA Eclipse 笔记参考 菜鸟教程-Java教程 "},"01-Java基础/01-快速开始.html":{"url":"01-Java基础/01-快速开始.html","title":"快速开始","keywords":"","body":"快速开始Table of contentsHelloWorld创建项目编辑HelloWorld.java基本语法关键字标识符修饰符Java变量代码注释快速开始 Table of contents 快速开始Table of contentsHelloWorld创建项目编辑HelloWorld.java基本语法关键字标识符修饰符Java变量代码注释 HelloWorld 创建项目 编辑HelloWorld.java 内容如下 public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在编辑器中编辑并执行. 实际上相当于执行了如下命令 # 使用javac命令将Java源文件编译为Class字节码文件 ➜ javac HelloWorld.java # 可以看到当前目录下多了一个 HelloWorld.class 文件 ➜ ls HelloWorld.class HelloWorld.java # 使用java命令装载和运行Class字节码, 会在终端输出\"Hello World!\" ➜ java HelloWorld Hello World! 基本语法 Java中的主要代码都会位于一个类中, 通过class关键字定义, 上面栗子的主要代码都在HelloWorld类中 public class HelloWorld { ... } Java对大小写敏感 程序的文件名必须和类名的完全相同, Java代码的文件都以类名加.java后缀进行命名 public static void main(String[] args)是一个方法, 是Java程序的入口 System.out.println()是一个方法, 会在输出内容后增加一个换行符, 而System.out.print()不会增加换行符 关键字 上面代码中的public, class, static等都是Java中的关键字(保留字) 关键字是编程语言保留这些单词用作特殊目的, 它们构成了编程语言语法的基本元素. Java关键字 标识符 类名, 变量名, 方法名, 方法参数名等都被成为标识符. 比如HelloWorld这个类名在代码中就是一种标识符. 标识符由我们自己命名 Java标识符, 需要注意下面几点 所有的标识符都应该以字母(A-Za-z), 美元符($), 或者下划线(_)开始 标识符由字母（A-Za-z）,美元符（$）、下划线（_）和数字组成 Java关键字不能用作标识符 例如: name、$user、_title和__1_content都是合法的标识符, 而12haha和-name都是非法标识符。 为了程序的可读性, 一般情况下 类名以大写字母开头, 比如HelloWorld以大写字母H开头 方法名一般以小写字母开头, 比如main方法以小写字母m开头 如果名称中包含几个单词, 从第二个单词开始每个单词首字母大写, 这种命名方式我们称之为驼峰命名法。 修饰符 像其他语言一样, Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符 访问控制修饰符 : default, public, protected, private 非访问控制修饰符 : final, abstract, strictfp Java变量 局部变量 类变量(静态变量) 成员变量(非静态变量) 代码注释 Java注释有下面三种 单行注释：在注释内容前加两个斜线// 多行注释：在要注释的内容前面添加/*, 在注释的内容后添加*/ 文档注释：在要注释的内容前面添加/**, 在注释的内容后添加*/, 这是一种特殊的多行注释, 注释中的内容可以用以生成程序的文档, 具体用法我们以后讲解。 "},"01-Java基础/02-类和对象.html":{"url":"01-Java基础/02-类和对象.html","title":"类和对象","keywords":"","body":"面向对象Table of contents类构造方法创建对象访问实例变量和方法源文件声明规则Java包import语句实例面向对象 Java是一门面向对象语言, 一个Java程序就是一系列对象（Object）的集合, 对象通过方法调用来彼此协作完成特定的功能。 类: 类是一个模板, 描述一类对象的行为和状态. 对象: 对象是类的一个实例 Table of contents 面向对象Table of contents类构造方法创建对象访问实例变量和方法源文件声明规则Java包import语句实例 类 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中, 方法结束后, 变量就会自动销毁。 成员变量：成员变量是定义在类中, 方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中, 方法体之外, 但必须声明为static类型。 示例 // public是一个修饰符, 表示外部可以访问这个类, public class Car { int color; // 成员变量 int speed; // 成员变量 // 成员方法 void startup() { System.out.println(\"启动!\"); } // 成员方法 void run(int speed) { System.out.println(\"我的速度是\" + speed); } } public class Post { String title; // 成员变量 String content; // 成员变量 // 成员方法 void print() { System.out.println(title); System.out.println(content); } } 构造方法 每个类都有构造方法。如果没有显式地为类定义构造方法, Java编译器将会为该类提供一个默认构造方法。 在创建一个对象的时候, 至少要调用一个构造方法。构造方法的名称必须与类同名, 一个类可以有多个构造方法。 下面是一个构造方法示例： public class Puppy{ public Puppy(){ } public Puppy(String name){ // 这个构造器仅有一个参数：name } } 创建对象 对象是根据类创建的。在Java中, 使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象, 包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时, 会调用构造方法初始化对象。 public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String []args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); } } 访问实例变量和方法 通过已创建的对象来访问成员变量和成员方法 /* 实例化对象 */ ObjectReference = new Constructor(); /* 访问类中的变量 */ ObjectReference.variableName; /* 访问类中的方法 */ ObjectReference.MethodName(); 实例 public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String []args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); } } 源文件声明规则 当在一个源文件中定义多个类, 并且还有import语句和package语句时, 要注意下列规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致 如果一个类定义在某个包中, 那么package语句应该放在源文件首行 如果源文件包含import语句, 那么应该放在package语句和类定义之间. 如果没有package语句, 那么import语句应该在源文件中最前面 import语句和package语句对源文件中定义的所有类都有效. 在同一源文件中, 不能给不通的类不通的包声明. Java还有一些特殊的类, 如: 内部类, 匿名类 Java包 包主要用来对类和接口进行分类. import语句 在Java中, 如果给出一个完整的限定名, 包括包名, 类名, 那么Java编译器就可以很容易地定位到源代码或者类. import语句就是用来提供一个合理的路径, 使得编辑器可以找到某个类. 例如, 下面的命令行将会命令编辑器载入java_installation/java/io路径下的所有类 import java.io.* 实例 创建两个类Employee, EmployeeTest Employee类由四个成员变量: name, age, designation, salary. 该类显式声明了一个构造方法, 该方法只有一个参数 import java.io.*; public class Employee { String name; int age; String designation; double salary; // Employee 类的构造器 public Employee(String name){ this.name = name; } // 设置age的值 public void empAge(int empAge){ age = empAge; } // 设置designation的值 public void empDesignation(String empDesig){ designation = empDesig; } // 设置salary的值 public void empSalary(double empSalary){ salary = empSalary; } // 打印信息 public void printEmployee(){ System.out.println(\"名字:\" + name); System.out.println(\"年龄:\" + age); System.out.println(\"职位\" + designation); System.out.println(\"薪水\" + salary); } } EmployeeTest.java 程序都是从main方法开始执行. 所以必须包含main方法, 并且创建一个实例对象. EmployeeTest类, 实例化两个Employee类的实例, 并调用方法设置变量的值. import java.io.*; public class EmployeeTest { public static void main(String args[]){ // 使用构造器创建两个对象 Employee empOne = new Employee(\"RUN00B1\"); Employee empTwo = new Employee(\"RUN00B2\"); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(\"高级程序员\"); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(\"菜鸟\"); empTwo.empSalary(500); empTwo.printEmployee(); } } run EmployeeTest.java结果 名字:RUN00B1 年龄:26 职位高级程序员 薪水1000.0 名字:RUN00B2 年龄:21 职位菜鸟 薪水500.0 "},"01-Java基础/03-基本数据类型.html":{"url":"01-Java基础/03-基本数据类型.html","title":"基本数据类型","keywords":"","body":"基本数据类型Table of contentsJava的两大数据类型内置数据类型byteshortintlongfloatdoublebooleanchar实例引用类型Java常量自动转换类型自动类型转换强制类型转换隐含强制类型转换基本数据类型 Table of contents 基本数据类型Table of contentsJava的两大数据类型内置数据类型byteshortintlongfloatdoublebooleanchar实例引用类型Java常量自动转换类型自动类型转换强制类型转换隐含强制类型转换 Java的两大数据类型 内置数据类型 引用数据类型 内置数据类型 Java提供了八种基本类型. 六种数字类型(四个整数型, 两个浮点型), 一种字符类型, 一种布尔型. byte byte 数据类型是8位、有符号的, 以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间, 主要代替整数, 因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100, byte b = -50。 short short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000, short r = -20000。 int int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000 long long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L, Long b = -200000L。 \"L\"理论上不分大小写, 但是若写成\"l\"容易与数字\"1\"混淆, 不容易分辩。所以最好大写。 float float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值, 如货币； 例子：float f1 = 234.5f。 double double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值, 如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char char类型是一个单一的 16 位 Unicode 字符； 最小值是 \\u0000（即为0）； 最大值是 \\uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = 'A'; 实例 对于数值类型的基本类型的取值范围, 我们无需强制去记忆, 因为它们的值都已经以变量的形式定义在对应的包装类中了. 运行下面的代码即可 public class PrimitiveTypeTest { public static void main(String[] args) { // byte System.out.println(\"基本类型：byte 二进制位数：\" + Byte.SIZE); System.out.println(\"包装类：java.lang.Byte\"); System.out.println(\"最小值：Byte.MIN_VALUE=\" + Byte.MIN_VALUE); System.out.println(\"最大值：Byte.MAX_VALUE=\" + Byte.MAX_VALUE); System.out.println(); // short System.out.println(\"基本类型：short 二进制位数：\" + Short.SIZE); System.out.println(\"包装类：java.lang.Short\"); System.out.println(\"最小值：Short.MIN_VALUE=\" + Short.MIN_VALUE); System.out.println(\"最大值：Short.MAX_VALUE=\" + Short.MAX_VALUE); System.out.println(); // int System.out.println(\"基本类型：int 二进制位数：\" + Integer.SIZE); System.out.println(\"包装类：java.lang.Integer\"); System.out.println(\"最小值：Integer.MIN_VALUE=\" + Integer.MIN_VALUE); System.out.println(\"最大值：Integer.MAX_VALUE=\" + Integer.MAX_VALUE); System.out.println(); // long System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE); System.out.println(\"包装类：java.lang.Long\"); System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE); System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE); System.out.println(); // float System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE); System.out.println(\"包装类：java.lang.Float\"); System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE); System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE); System.out.println(); // double System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE); System.out.println(\"包装类：java.lang.Double\"); System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE); System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE); System.out.println(); // char System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE); System.out.println(\"包装类：java.lang.Character\"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println(\"最小值：Character.MIN_VALUE=\" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println(\"最大值：Character.MAX_VALUE=\" + (int) Character.MAX_VALUE); } } Float和Double的最小值和最大值都是以科学记数法的形式输出的, 结尾的\"E+数字\"表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 10^3 =3140, 3.14E-3就是 3.14 x 10^-3 =0.00314。 实际上, JAVA中还存在另外一种基本类型void, 它也有对应的包装类 java.lang.Void, 不过我们无法直接对它们进行操作。 引用类型 在Java中, 引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象, 指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型, 比如 Employee、Puppy 等。变量一旦声明后, 类型就不能被改变了。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 例子：Site site = new Site(\"Runoob\")。 Java常量 常量在程序运行时, 不会被修改的量。 在 Java 中使用 final 关键字来修饰常量, 声明方式和变量类似 final double PI = 3.1415927; 虽然常量名也可以用小写, 但为了便于识别, 通常使用大写字母表示常量。 字面量可以赋给任何内置类型的变量。例如： byte a = 68; char a = 'A' byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。 当使用常量的时候, 前缀0\b表示8进制, 而前缀0x代表16进制。例如 int decimal = 100; int octal = 0144; int hexa = 0x64; 和其他语言一样, Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子 \"Hello World\" \"two\\nlines\" \"\\\"This is in quotes\\\"\" 字符串常量和字符常量都可以包含任何Unicode字符。例如： char a = '\\u0001'; String a = \"\\u0001\"; Java支持一些特殊的转义字符序列 符号 字符含义 \\n 换行 (0x0a) \\r 回车 (0x0d) \\f 换页符(0x0c) \\b 退格 (0x08) \\0 空字符 (0x20) \\s 字符串 \\t 制表符 \\\" 双引号 \\' 单引号 \\ 反斜杠 \\ddd 八进制字符 (ddd) \\uxxxx 16进制Unicode字符 (xxxx) 自动转换类型 整型, 实型(常量), 字符型数据可以混合运算. 运算中, 不同类型的数据线转换为同一类型, 然后进行运算 转换从低级到高级 低 ------------------------------------> 高 byte,short,char—> int —> long—> float —> double 数据类型转换必须满足如下规则 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转换过程中可能导致溢出或损失精度 int i =128; byte b = (byte)i; // 因为byte类型时8位, 最大值为127, 所以当强制转换为int类型值128时候就会导致溢出。 浮点数到整数的转换是通过舍弃小数得到, 而不是四舍五入 (int)23.7 == 23; (int)-45.89f == -45 自动类型转换 必须满足转换前的数据类型的位数要低于转换后的数据类型, 例如: short数据类型的位数为16位, 就可以自动转换位数为32的int类型, 同样float数据类型的位数为32, 可以自动转换为64位的double类型。 public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1='a';//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(\"char自动类型转换为int后的值等于\"+i1); char c2 = 'A';//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(\"char类型和int计算后的值等于\"+i2); } } c1的值为字符'a',查ascii码表可知对应的int类型值为97, 'A'对应值为65, 所以i2=65+1=66。 强制类型转换 条件是转换的数据类型必须是兼容的。 格式：(type)value type是要强制类型转换后的数据类型 public class QiangZhiZhuanHuan{ public static void main(String[] args){ int i1 = 123; byte b = (byte)i1;//强制类型转换为byte System.out.println(\"int强制类型转换为byte后的值等于\"+b); } } 隐含强制类型转换 整数的默认类型是 int。 浮点型不存在这种情况, 因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 这一节讲解了 Java 的基本数据类型。下一节将探讨不同的变量类型以及它们的用法。 "},"01-Java基础/04-变量类型.html":{"url":"01-Java基础/04-变量类型.html","title":"变量类型","keywords":"","body":"变量类型Table of contentsJava局部变量实例变量类变量(静态变量)变量类型 Java中, 所有变量使用前必须声明, 声明格式如下 type identifier [ = value ][, identifier [ = value ] ...]; type为Java数据类型. identifier是变量名. 可以使用逗号隔开声明多个同类型变量. 示例 int a, b, c; // 声明三个int型整数：a、 b、c int d = 3, e = 4, f = 5; // 声明三个整数并赋予初值 byte z = 22; // 声明并初始化 z String s = \"runoob\"; // 声明并初始化字符串 s double pi = 3.14159; // 声明了双精度浮点型变量 pi char x = 'x'; // 声明变量 x 的值是字符 'x'。 Java支持的变量类型有 类变量: 独立于方法之外的变量, 用static修饰 实例变量: 独立于方法之外的变量, 不过没有static修饰 局部变量: 类的方法中的变量 实例 public class Variable{ static int allClicks=0; // 类变量 String str=\"hello world\"; // 实例变量 public void method(){ int i =0; // 局部变量 } } Table of contents 变量类型Table of contentsJava局部变量实例变量类变量(静态变量) Java局部变量 局部变量声明在方法、构造方法或者语句块中; 局部变量在方法、构造方法、或者语句块被执行的时候创建, 当它们执行完成后, 变量将会被销毁; 访问修饰符不能用于局部变量; 局部变量只在声明它的方法、构造方法或者语句块中可见; 局部变量是在栈上分配的。 局部变量没有默认值, 所以局部变量被声明后, 必须经过初始化, 才可以使用。 public class Test_par { public void pupAge(){ // 如果age不进行初始化, 下一句, 就会报错 int age = 0; age = age + 7; System.out.println(\"小狗的年龄: \" + age); } public static void main(String args[]){ Test_par test = new Test_par(); test.pupAge(); } } 实例变量 实例变量声明在一个类中, 但在方法、构造方法和语句块之外; 当一个对象被实例化之后, 每个实例变量的值就跟着确定; 实例变量在对象创建的时候创建, 在对象被销毁的时候销毁; 实例变量的值应该至少被一个方法、构造方法或者语句块引用, 使得外部能够通过这些方式获取实例变量信息; 实例变量可以声明在使用前或者使用后; 访问修饰符可以修饰实例变量; 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见; 实例变量具有默认值。数值型变量的默认值是0, 布尔型变量的默认值是false, 引用类型变量的默认值是null。变量的值可以在声明时指定, 也可以在构造方法中指定; 实例变量可以直接通过变量名访问。但在静态方法以及其他类中, 就应该使用完全限定名：ObejectReference.VariableName。 实例 public class Employee_par { public String name; private double salary; public Employee_par(String empName){ name = empName; } public void setSalary(double empSal){ salary = empSal; } public void printEmp(){ System.out.println(\"名字: \" + name); System.out.println(\"薪水: \" + salary); } public static void main(String args[]){ Employee_par empOne = new Employee_par(\"haha\"); empOne.setSalary(1000); empOne.printEmp(); } } 运行结果 名字: haha 薪水: 1000.0 类变量(静态变量) 类变量也称为静态变量, 在类中以static关键字声明, 但必须在方法构造方法和语句块之外。 无论一个类创建了多少个对象, 类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private, final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量, 很少单独使用static声明变量。 静态变量在程序开始时创建, 在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见, 大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0, 布尔型默认值是false, 引用类型默认值是null。变量的值可以在声明的时候指定, 也可以在构造方法中指定。此外, 静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时, 类变量名称一般建议使用大写字母。如果静态变量不是public和final类型, 其命名方式与实例变量以及局部变量的命名方式一致。 public class Employee { //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = \"开发人员\"; public static void main(String args[]){ salary = 10000; System.out.println(DEPARTMENT+\"平均工资:\"+salary); } } "},"01-Java基础/05-修饰符.html":{"url":"01-Java基础/05-修饰符.html","title":"修饰符","keywords":"","body":"修饰符Table of contents访问控制修饰符defaultprivatepublicprotected访问控制和继承非访问修饰符staticfinalabstract抽象方法synchronizedtransientvolatile修饰符 Java提供了很多修饰符, 主要分为下面两类 访问修饰符 非访问修饰符 修饰符用来定义类, 方法或者变量, 通常放在语句的最前端. public class className { // ... } private boolean myFlag; static final double weeks = 9.5; protected static final int BOXWIDTH = 42; public static void main(String[] arguments) { // 方法体 } Table of contents 修饰符Table of contents访问控制修饰符defaultprivatepublicprotected访问控制和继承非访问修饰符staticfinalabstract抽象方法synchronizedtransientvolatile 访问控制修饰符 Java中, 可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。 default (即缺省, 什么也不写): 在同一包内可见, 不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类(外部类) public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类(外部类)。 修饰符 当前类 同一包内 子孙类 其他包 public Y Y Y Y protected Y Y Y N default Y Y N N private Y N N N default 不使用任何关键字 使用默认访问修饰符声明的变量和方法, 对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 实例, 变量和方法的声明可以不使用任何修饰符。 String version = \"1.5.1\"; boolean processOrder() { return true; } private 私有访问修饰符是最严格的访问级别, 所以被声明为 private 的方法、变量和构造方法只能被所属类访问, 并且类和接口不能声明为 private。 声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。 Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。 // Logger 类 public class Logger { // format 变量为私有变量, 其他类不能直接得到和设置该变量的值 private String format; // 为了使其他类能够操作该变量, 定义了两个 public 方法：getFormat() (返回 format的值) public String getFormat() { return this.format; } // setFormat(String)(设置 format 的值) public void setFormat(String format) { this.format = format; } } public 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。 如果几个相互访问的 public 类分布在不同的包中, 则需要导入相应 public 类所在的包。由于类的继承性, 类所有的公有方法和变量都能被其子类继承。 // Java 程序的 main() 方法必须设置成公有的, 否则, Java 解释器将不能运行该类。 public static void main(String[] arguments) { // ... } protected 被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问, 也能够被不同包中的子类访问。 protected 访问修饰符不能修饰类和接口, 方法和成员变量能够声明为 protected, 但是接口的成员变量和成员方法不能声明为 protected。 子类能访问 protected 修饰符声明的方法和变量, 这样就能保护不相关的类使用这些方法和变量。 下面的父类使用了 protected 访问修饰符, 子类重写了父类的 openSpeaker() 方法。 class AudioPlayer { protected boolean openSpeaker(Speaker sp) { // 实现细节 } } class StreamingAudioPlayer extends AudioPlayer { protected boolean openSpeaker(Speaker sp) { // 实现细节 } } 如果把 openSpeaker() 方法声明为 private, 那么除了 AudioPlayer 之外的类将不能访问该方法。 如果把 openSpeaker() 声明为 public, 那么所有的类都能够访问该方法。 如果我们只想让该方法对其所在类的子类可见, 则将该方法声明为 protected。 访问控制和继承 请注意以下方法继承的规则 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected, 要么声明为 public, 不能声明为 private 父类中声明为 private 的方法, 不能够被继承。 非访问修饰符 为了实现一些其他的功能, Java 也提供了许多非访问修饰符。 static 修饰符, 用来修饰类方法和类变量。 final 修饰符, 用来修饰类、方法和变量, final 修饰的类不能够被继承, 修饰的方法不能被继承类重新定义, 修饰的变量为常量, 是不可修改的。 abstract 修饰符, 用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符, 主要用于线程的编程。 static 静态变量: static关键字用来声明独立于对象的静态变量, 无论一个类实例化多少对象, 它的静态变量只有一份拷贝. 静态变量也称为类变量. 局部变量不能被声明为static变量 静态方法: static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据, 然后计算这些数据。 对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname() 的方式访问。 如下例所示, static修饰符用来创建类方法和类变量。 public class InstanceCounter { private static int numInstances = 0; protected static int getCount() { return numInstances; } private static void addInstance() { numInstances++; } InstanceCounter() { InstanceCounter.addInstance(); } public static void main(String[] arguments) { System.out.println(\"Starting with \" + InstanceCounter.getCount() + \" instances\"); for (int i = 0; i 运行结果 Started with 0 instances Created 500 instances final final 变量 final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变, 但是里面的值可以改变。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 实例 public class Test{ final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = \"Manager\"; public void changeValue(){ value = 12; //将输出一个错误 } } final 方法 类中的 final 方法可以被子类继承, 但是不能被子类修改。 声明 final 方法的主要目的是防止该方法的内容被修改。 如下所示, 使用 final 修饰符声明方法。 public class Test{ public final void changeName(){ // 方法体 } } final 类 final 类不能被继承, 没有类能够继承 final 类的任何特性。 实例 public final class Test { // 类体 } abstract 抽象类 抽象类不能用来实例化对象, 声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法, 那么该类一定要声明为抽象类, 否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 实例 abstract class Caravan{ private double price; private String model; private String year; public abstract void goFast(); //抽象方法 public abstract void changeColor(); } 抽象方法 抽象方法是一种没有任何实现的方法, 该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法, 除非该子类也是抽象类。 如果一个类包含若干个抽象方法, 那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾, 例如：public abstract sample(); 实例 public abstract class SuperClass{ abstract void m(); //抽象方法 } class SubClass extends SuperClass{ //实现抽象方法 void m(){ ......... } } synchronized synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。 public synchronized void showDetails(){ ....... } transient 序列化的对象包含被 transient 修饰的实例变量时, java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中, 用来预处理类和变量的数据类型。 public transient int limit = 55; // 不会持久化 public int b; // 持久化 volatile volatile 修饰的成员变量在每次被线程访问时, 都强制从共享内存中重新读取该成员变量的值。而且, 当成员变量发生变化时, 会强制线程将变化值回写到共享内存。这样在任何时刻, 两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null public class MyRunnable implements Runnable { private volatile boolean active; public void run() { active = true; while (active) // 第一行 { // 代码 } } public void stop() { active = false; // 第二行 } } 通常情况下, 在一个线程调用 run() 方法（在 Runnable 开启的线程）, 在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用, 那么在 第二行 的 active 值为 false 时循环不会停止。 但是以上代码中我们使用了 volatile 修饰 active, 所以该循环会停止。 "},"01-Java基础/06-运算符.html":{"url":"01-Java基础/06-运算符.html","title":"运算符","keywords":"","body":"运算符Table of contents算术运算符自增自减关系运算符位运算符运算符 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 Java运算符 Table of contents 运算符Table of contents算术运算符自增自减关系运算符位运算符 算术运算符 变量A的值为10, 变量B的值为20 操作符 描述 例子 + 加法 相加运算符两侧的值 A + B 等于 30 - 减法 左操作数减去右操作数 A – B 等于 -10 * 乘法 相乘操作符两侧的值 A * B等于200 / 除法 左操作数除以右操作数 B / A等于2 ％ 取模 左操作数除以右操作数的余数 B%A等于0 ++ 自增 操作数的值增加1 B++ 或 ++B 等于 21 -- 自减 操作数的值减少1 B-- 或 --B 等于 19 自增自减 自增（++）自减（--）运算符是一种特殊的算术运算符, 在算术运算符中需要两个操作数来进行运算, 而自增自减运算符是一个操作数。 前缀自增自减法(++a,--a): 先进行自增或者自减运算, 再进行表达式运算。 后缀自增自减法(a++,a--): 先进行表达式运算, 再进行自增或者自减运算 实例： 关系运算符 变量A的值为10, 变量B的值为20 运算符 描述 例子 == 检查如果两个操作数的值是否相等, 如果相等则条件为真。 （A == B）为假(非真)。 != 检查如果两个操作数的值是否相等, 如果值不相等则条件为真。 (A != B) 为真。 > 检查左操作数的值是否大于右操作数的值, 如果是那么条件为真。 （A> B）非真。 检查左操作数的值是否小于右操作数的值, 如果是那么条件为真。 （A > = 检查左操作数的值是否大于或等于右操作数的值, 如果是那么条件为真。 （A> = B）为假。 检查左操作数的值是否小于或等于右操作数的值, 如果是那么条件为真。 （A 位运算符 "},"01-Java基础/07-循环结构.html":{"url":"01-Java基础/07-循环结构.html","title":"循环结构","keywords":"","body":"循环结构Table of contentswhile循环do…while 循环for循环增强for循环breakcontinue循环结构 Java主要有三种循环结构 while 循环 do…while 循环 for 循环 Table of contents 循环结构Table of contentswhile循环do…while 循环for循环增强for循环breakcontinue while循环 // 只要布尔表达式为 true, 循环体会一直执行下去。 while( 布尔表达式 ) { //循环内容 } 实例 public class Text_while_1 { public static void main(String args[]){ int x = 10; while (x do…while 循环 对于 while 语句而言, 如果不满足条件, 则不能进入循环。但有时候我们需要即使不满足条件, 也至少执行一次。 do…while 循环和 while 循环相似, 不同的是, do…while 循环至少会执行一次。 do { //代码语句 }while(布尔表达式); 注意：布尔表达式在循环体的后面, 所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true, 则语句块一直执行, 直到布尔表达式的值为 false. 实例 public class Test { public static void main(String args[]){ int x = 10; do{ System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); }while( x for循环 虽然所有循环结构都可以用 while 或者 do...while 表示, 但 Java 提供了另一种语句, for 循环, 使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。 for(初始化; 布尔表达式; 更新) { //代码语句 } 关于 for 循环有以下几点说明 最先执行初始化步骤。可以声明一种类型, 但可初始化一个或多个循环控制变量, 也可以是空语句。 然后, 检测布尔表达式的值。如果为 true, 循环体被执行。如果为 false, 循环终止, 开始执行循环体后面的语句。 执行一次循环后, 更新循环控制变量。 再次检测布尔表达式。循环执行上面的过程。 实例 public class Test_for_1 { public static void main(String args[]){ for (int x = 10; x 增强for循环 Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: for(声明语句 : 表达式) { //代码句子 } 声明语句：声明新的局部变量, 该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块, 其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名, 或者是返回值为数组的方法。 实例 public class Test_for_2 { public static void main(String args[]){ int [] numbers = {10, 20, 30, 40, 50}; for (int x : numbers){ System.out.print(x); System.out.print(\",\"); } System.out.print(\"\\n\"); String [] names = {\"James\", \"Larry\", \"Tom\", \"Lacy\"}; for (String name : names){ System.out.print(name); System.out.print(\",\"); } } } break break 主要用在循环语句或者 switch 语句中, 用来跳出整个语句块。 break 跳出最里层的循环, 并且继续执行该循环下面的语句。 continue continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中, continue 语句使程序立即跳转到更新语句。 在 while 或者 do…while 循环中, 程序立即跳转到布尔表达式的判断语句。 "},"01-Java基础/08-分支结构.html":{"url":"01-Java基础/08-分支结构.html","title":"分支结构","keywords":"","body":"分支结构Table of contentsif语句if...else语句if...else if...elseswitch 语句分支结构 if 语句 switch 语句 可以嵌套 Table of contents 分支结构Table of contentsif语句if...else语句if...else if...elseswitch 语句 if语句 一个 if 语句包含一个布尔表达式和一条或多条语句。 if(布尔表达式) { //如果布尔表达式为true将执行的语句 } if...else语句 if 语句后面可以跟 else 语句, 当 if 语句的布尔表达式值为 false 时, else 语句块会被执行。 if(布尔表达式){ //如果布尔表达式的值为true }else{ //如果布尔表达式的值为false } if...else if...else 使用 if, else if, else 语句的时候, 需要注意下面几点 if 语句至多有 1 个 else 语句, else 语句在所有的 else if 语句之后。 if 语句可以有若干个 else if 语句, 它们必须在 else 语句之前。 一旦其中一个 else if 语句检测为 true, 其他的 else if 以及 else 语句都将跳过执行。 if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码 }else if(布尔表达式 2){ //如果布尔表达式 2的值为true执行代码 }else if(布尔表达式 3){ //如果布尔表达式 3的值为true执行代码 }else { //如果以上布尔表达式都不为true执行代码 } switch 语句 switch 语句判断一个变量与一系列值中某个值是否相等, 每个值称为一个分支。 switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } switch 语句有如下规则 switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始, switch 支持字符串类型了, 同时 case 标签必须为字符串常量或字面量。 switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。 case 语句中的值的数据类型必须与变量的数据类型相同, 而且只能是常量或者字面常量。 当变量的值与 case 语句的值相等时, 那么 case 语句之后的语句开始执行, 直到 break 语句出现才会跳出 switch 语句。 当遇到 break 语句时, switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现, 程序会继续执行下一条 case 语句, 直到出现 break 语句。 switch 语句可以包含一个 default 分支, 该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 实例 public class Test { public static void main(String args[]){ //char grade = args[0].charAt(0); char grade = 'C'; switch(grade) { case 'A' : System.out.println(\"优秀\"); break; case 'B' : case 'C' : System.out.println(\"良好\"); break; case 'D' : System.out.println(\"及格\"); case 'F' : System.out.println(\"你需要再努力努力\"); break; default : System.out.println(\"未知等级\"); } System.out.println(\"你的等级是 \" + grade); } } "},"01-Java基础/13-数组.html":{"url":"01-Java基础/13-数组.html","title":"数组","keywords":"","body":"数组Table of contents声明数组对象数组*案例数组 Table of contents 数组Table of contents声明数组对象数组*案例 声明数组 首先必须声明数组变量，才能在程序中使用数组。 dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，C/C++ 风格 对象数组* 数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。 案例 用数组存储5个学生对象，并遍历数组。 "},"01-Java基础/14-日期时间.html":{"url":"01-Java基础/14-日期时间.html","title":"日期时间","keywords":"","body":"日期时间Table of contents获取当前日期时间日期比较DateTimeFormatter使用 SimpleDateFormat 格式化日期使用printf格式化日期日期时间 http://www.runoob.com/java/java-date-time.html java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。 Date( ) 第二个构造函数接收一个参数, 该参数是从1970年1月1日起的毫秒数。 Date(long millisec) 创建Date对象之后, 可以使用下面的方法 Table of contents 日期时间Table of contents获取当前日期时间日期比较DateTimeFormatter使用 SimpleDateFormat 格式化日期使用printf格式化日期 获取当前日期时间 import java.util.Date; public class Date_toString { public static void main(String args[]){ Date date = new Date(); System.out.println(date.toString()); } } 日期比较 Java使用以下三种方法来比较两个日期 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值）, 然后比较这两个值。 使用方法 before(), after() 和 equals()。例如, 一个月的12号比18号早, 则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法, 它是由 Comparable 接口定义的, Date 类实现了这个接口。 DateTimeFormatter 使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。 import java.util.*; import java.text.*; public class SimpleDateFormat_xx { public static void main(String args[]) { Date dNow = new Date( ); /* 这一行代码确立了转换的格式, 其中 yyyy 是完整的公元年, MM 是月份, dd 是日期, HH:mm:ss 是时、分、秒。 注意:有的格式大写, 有的格式小写, 例如 MM 是月份, mm 是分；HH 是 24 小时制, 而 hh 是 12 小时制。*/ SimpleDateFormat ft = new SimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\"); System.out.println(\"Current Date: \" + ft.format(dNow)); } } 使用printf格式化日期 printf 方法可以很轻松地格式化时间和日期。使用两个字母格式, 它以 %t 开头并且以下面表格中的一个字母结尾。 import java.util.Date; public class DateDemo { public static void main(String args[]) { // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\",date); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\",date); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\",date); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\",date); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\",date); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\",date); } } "},"01-Java基础/16-方法.html":{"url":"01-Java基础/16-方法.html","title":"方法","keywords":"","body":"方法Table of contents方法的定义方法调用方法 Table of contents 方法Table of contents方法的定义方法调用 方法的定义 一般情况下, 定义一个方法包含以下语法 修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值; } 方法包含一个方法头和一个方法体。下面是一个方法的所有部分 修饰符：修饰符, 这是可选的, 告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型 ：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作, 但没有返回值。在这种情况下, returnValueType 是关键字void。 方法名：是方法的实际名称。方法名和参数表共同构成方法签名。 参数类型：参数像是一个占位符。当方法被调用时, 传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的, 方法可以不包含任何参数。 方法体：方法体包含具体的语句, 定义该方法的功能。 方法调用 Java 支持两种调用方法的方式, 根据方法是否返回值来选择。 当程序调用一个方法时, 程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。 当方法返回一个值的时候, 方法调用通常被当做一个值。例如： int larger = max(30, 40); 如果方法返回值是void, 方法调用一定是一条语句。例如, 方法println返回void。下面的调用是个语句： System.out.println(\"Hello World\"); "},"01-Java基础/17-IO.html":{"url":"01-Java基础/17-IO.html","title":"IO","keywords":"","body":"Stream,File,IOTable of contentsFileFileInputStreamFileOutputStreamStream,File,IO Table of contents Stream,File,IOTable of contentsFileFileInputStreamFileOutputStream File 掌握 IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件 构造方法 File file = new File(\"e:\\\\demo\\\\a.txt\"); File file = new File(\"e:\\\\demo\",\"a.txt\"); File file = new File(\"e:\\\\demo\"); File file2 = new File(file,\"a.txt\"); File类的功能(自己补齐) 创建功能 删除功能 重命名功能 判断功能 获取功能 高级获取功能 过滤器功能 案例： 输出指定目录下指定后缀名的文件名称 先获取所有的，在遍历的时候判断，再输出 先判断，再获取，最后直接遍历输出即可 批量修改文件名称 FileInputStream FileOutputStream 实例 fileStreamTest.java import java.io.*; public class fileStreamTest{ public static void main(String args[]){ try{ byte bWrite [] = {11,21,3,40,5}; OutputStream os = new FileOutputStream(\"test.txt\"); for(int x=0; x 上面使用二进制形式写入文件, 同时输出到控制台, 如下代码解决乱码问题 fileStreamTest2.java //文件名 :fileStreamTest2.java import java.io.*; public class fileStreamTest2{ public static void main(String[] args) throws IOException { File f = new File(\"a.txt\"); FileOutputStream fop = new FileOutputStream(f); // 构建FileOutputStream对象,文件不存在会自动新建 OutputStreamWriter writer = new OutputStreamWriter(fop, \"UTF-8\"); // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk writer.append(\"中文输入\"); // 写入到缓冲区 writer.append(\"\\r\\n\"); //换行 writer.append(\"English\"); // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入 writer.close(); //关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉 fop.close(); // 关闭输出流,释放系统资源 FileInputStream fip = new FileInputStream(f); // 构建FileInputStream对象 InputStreamReader reader = new InputStreamReader(fip, \"UTF-8\"); // 构建InputStreamReader对象,编码与写入相同 StringBuffer sb = new StringBuffer(); while (reader.ready()) { sb.append((char) reader.read()); // 转成char加到StringBuffer对象中 } System.out.println(sb.toString()); reader.close(); // 关闭读取流 fip.close(); // 关闭输入流,释放系统资源 } } "},"01-Java基础/18-Scanner类.html":{"url":"01-Java基础/18-Scanner类.html","title":"Scanner类","keywords":"","body":"ScannerScanner java.util.Scanner 是 Java5 的新特征, 我们可以通过 Scanner 类来获取用户的输入。 "},"01-Java基础/19-异常.html":{"url":"01-Java基础/19-异常.html","title":"异常","keywords":"","body":"异常Table of contents异常体系内置异常异常处理捕获异常多重捕获块捕获方式throws/throwfinally自定义异常编译器异常和运行期异常异常注意事项异常 Table of contents 异常Table of contents异常体系内置异常异常处理捕获异常多重捕获块捕获方式throws/throwfinally自定义异常编译器异常和运行期异常异常注意事项 异常体系 程序出现的不正常的情况. 异常的体系 Throwable |--Error 严重问题, 我们不处理. |--Exception |--RuntimeException 运行期异常, 我们需要修正代码 |--非RuntimeException 编译期异常, 必须处理的, 否则程序编译不通过 内置异常 异常处理 JVM的默认处理 把异常的名称,原因,位置等信息输出在控制台, 但是呢程序不能继续执行了. 自己处理 a:try...catch...finally 自己编写处理代码,后面的程序可以继续执行 b:throws 把自己处理不了的, 在方法上声明, 告诉调用者, 这里有问题 捕获异常 使用 try 和 catch 关键字可以捕获异常. try/catch 代码块放在异常可能发生的地方. try/catch代码块中的代码称为保护代码, 使用 try/catch 的语法如下： try { // 程序代码 }catch(ExceptionName e1) { //catch 块 } catch 语句包含要捕获异常类型的声明. 当保护代码块中发生一个异常时, try 后面的 catch 块就会被检查. 如果发生的异常包含在 catch 块中, 异常会被传递到该 catch 块, 这和传递一个参数到方法是一样. 实例 下面的例子中声明有两个元素的一个数组, 当代码试图访问数组的第三个元素的时候就会抛出一个异常. // 文件名 : ExcepTest.java import java.io.*; public class ExcepTest{ public static void main(String args[]){ try{ int a[] = new int[2]; System.out.println(\"Access element three :\" + a[3]); }catch(ArrayIndexOutOfBoundsException e){ System.out.println(\"Exception thrown :\" + e); } System.out.println(\"Out of the block\"); } } 多重捕获块 一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获. try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 } 上面的代码段包含了 3 个 catch块. 可以在 try 语句后面添加任意数量的 catch 块. 如果保护代码中发生异常, 异常被抛给第一个 catch 块. 如果抛出异常的数据类型与 ExceptionType1 匹配, 它在这里就会被捕获. 如果不匹配, 它会被传递给第二个 catch 块. 如此, 直到异常被捕获或者通过所有的 catch 块. 实例 try { file = new FileInputStream(fileName); x = (byte) file.read(); }catch(IOException i) { i.printStackTrace(); return -1; }catch(FileNotFoundException f) //Not valid! { f.printStackTrace(); return -1; } 捕获方式 try...catch...finally try...catch... try...catch...catch... try...catch...catch...fianlly try...finally throws/throw throws 如果一个方法有捕获一个检查性异常, 那么该方法必须使用 throws 关键字来声明. throws 关键字放在方法签名的尾部. 在方法声明上,后面跟的是异常的类名,可以是多个 throws是声明方法有异常, 是一种可能性, 这个异常并不一定会产生 throw 在方法体中, 后面跟异常对象名, 并且只能是一个 throw 触发异常, 无论它是新实例化的还是刚捕获到的. 下面方法的声明抛出一个 RemoteException 异常： import java.io.*; public class className { public void deposit(double amount) throws RemoteException { // Method implementation throw new RemoteException(); } //Remainder of class definition } 一个方法可以声明抛出多个异常, 多个异常之间用逗号隔开. 例如, 下面的方法声明抛出 RemoteException 和 InsufficientFundsException import java.io.*; public class className { public void withdraw(double amount) throws RemoteException, InsufficientFundsException { // Method implementation } //Remainder of class definition } finally finally 关键字用来创建在 try 代码块后面执行的代码块. 无论是否发生异常, finally 代码块中的代码总会被执行, 以运行清理类型等收尾善后性质的语句. 特殊情况: 在执行到finally之前JVM退出了 finally 代码块出现在 catch 代码块最后 try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 注意下面事项 catch 不能独立于 try 存在. 在 try/catch 后面添加 finally 块并非强制性要求的. try 代码后不能既没 catch 块也没 finally 块. try, catch, finally 块之间不能添加任何代码. 自定义异常 在 Java 中你可以自定义异常. 编写自己的异常类时需要记住下面的几点. 所有异常都必须是 Throwable 的子类. 如果希望写一个检查性异常类, 则需要继承 Exception 类. 如果你想写一个运行时异常类, 那么需要继承 RuntimeException 类. 只需要提供无参构造和一个带参构造即可 可以像下面这样定义自己的异常类： class MyException extends Exception{ } 只继承Exception 类来创建的异常类是检查性异常类. 下面的 InsufficientFundsException 类是用户定义的异常类, 它继承自 Exception. 一个异常类和其它任何类一样, 包含有变量和方法. 编译器异常和运行期异常 编译期异常 必须要处理的, 否则编译不通过 运行期异常 可以不处理, 也可以处理 异常注意事项 异常的注意实现 父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 父的方法没有异常抛出,子的重写方法不能有异常抛出 父的方法抛出多个异常,子的重写方法必须比父少或者小 "},"02-面向对象/":{"url":"02-面向对象/","title":"面向对象","keywords":"","body":"面向对象面向对象 Java为面向对象语言, 有以下基本概念 多态 继承 封装 抽象 类 对象 实例 方法 重载 "},"02-面向对象/01-继承.html":{"url":"02-面向对象/01-继承.html","title":"继承","keywords":"","body":"继承Table of contents类的继承格式继承的特性继承关键字extends关键字implementssuper 与 thisfinal构造器继承 Table of contents 继承Table of contents类的继承格式继承的特性继承关键字extends关键字implementssuper 与 thisfinal构造器 类的继承格式 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的, 一般形式如下 class 父类 { } class 子类 extends 父类 { } 继承的特性 子类拥有父类非private的属性, 方法。 子类可以拥有自己的属性和方法, 即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java的继承是单继承, 但是可以多重继承, 单继承就是一个子类只能继承一个父类, 多重继承就是, 例如A类继承B类, B类继承C类, 所以按照关系就是C类是B类的父类, B类是A类的父类, 这是java继承区别于C++继承的一个特性。 提高了类之间的耦合性(继承的缺点, 耦合度高就会造成代码之间的联系) 继承关键字 继承可以使用 extends 和 implements 这两个关键字来实现继承, 而且所有的类都是继承于 java.lang.Object, 当一个类没有继承的两个关键字, 则默认继承object（这个类在 java.lang 包中, 所以不需要 import）祖先类。 extends关键字 在 Java 中, 类的继承是单一继承, 也就是说, 一个子类只能拥有一个父类, 所以 extends 只能继承一个类。 public class Animal { private String name; private int id; public Animal(String myName, String myid) { //初始化属性值 } public void eat() { //吃东西方法的具体实现 } public void sleep() { //睡觉方法的具体实现 } } public class Penguin extends Animal{ } implements 使用 implements 关键字可以变相的使java具有多继承的特性, 使用范围为类继承接口的情况, 可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 public interface A { public void eat(); public void sleep(); } public interface B { public void show(); } public class C implements A,B { } super 与 this super关键字：我们可以通过super关键字来实现对父类成员的访问, 用来引用当前对象的父类。 this关键字：指向自己的引用。 class Animal { void eat() { System.out.println(\"animal : eat\"); } } class Dog extends Animal { void eat() { System.out.println(\"dog : eat\"); } void eatTest() { this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 } } public class Test { public static void main(String[] args) { Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); } } final final 关键字声明类可以把类定义为不能继承的, 即最终类；或者用于修饰方法, 该方法不能被子类重写： 声明类 final class 类名 {//类体} 声明方法 修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体} 注:实例变量也可以被定义为 final, 被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final, 但是实例变量并不是 final 构造器 子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。 如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。 class SuperClass { private int n; SuperClass(){ System.out.println(\"SuperClass()\"); } SuperClass(int n) { System.out.println(\"SuperClass(int n)\"); this.n = n; } } class SubClass extends SuperClass{ private int n; SubClass(){ super(300); System.out.println(\"SubClass\"); } public SubClass(int n){ System.out.println(\"SubClass(int n):\"+n); this.n = n; } } public class TestSuperSub{ public static void main (String args[]){ SubClass sc = new SubClass(); SubClass sc2 = new SubClass(200); } } 输出结果 SuperClass(int n) SubClass SuperClass() SubClass(int n):200 "},"02-面向对象/02-重写与重载.html":{"url":"02-面向对象/02-重写与重载.html","title":"重写与重载","keywords":"","body":"重写与重载Table of contents重写(Override)方法的重写规则Super关键字的使用重载(Overload)重写与重载之间的区别总结重写与重载 Table of contents 重写与重载Table of contents重写(Override)方法的重写规则Super关键字的使用重载(Overload)重写与重载之间的区别总结 重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 } } 在上面的例子中可以看到，尽管b属于Animal类型，但是它运行的是Dog类的move方法。 这是由于在编译阶段，只是检查参数的引用类型。 然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。 因此在上面的例子中，之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。 TestDog.java class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ System.out.println(\"狗可以跑和走\"); } public void bark(){ System.out.println(\"狗可以吠叫\"); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 // 程序会报错, 因为b的引用类型Animal没有bark方法, 可以将b声明为Dog b.bark(); } } 以上实例编译运行结果如下 Error:(23, 10) java: cannot find symbol symbol: method bark() location: variable b of type Animal 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用 当需要在子类中调用父类的被重写方法时，要使用super关键字。 TestDog.java class Animal{ public void move(){ System.out.println(\"动物可以移动\"); } } class Dog extends Animal{ public void move(){ super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); } } public class TestDog{ public static void main(String args[]){ Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 } } 重载(Overload) 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 实例Overloading.java public class Overloading { public int test(){ System.out.println(\"test1\"); return 1; } public void test(int a){ System.out.println(\"test2\"); } //以下两个参数类型顺序不同 public String test(int a,String s){ System.out.println(\"test3\"); return \"returntest3\"; } public String test(String s,int a){ System.out.println(\"test4\"); return \"returntest4\"; } public static void main(String[] args){ Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); } } 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 "},"02-面向对象/03-多态.html":{"url":"02-面向对象/03-多态.html","title":"多态","keywords":"","body":"多态Table of contents多态的优点多态存在的三个必要条件多态 多态是同一个行为具有多个不同表现形式或形态的能力. 多态就是同一个接口, 使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现 Table of contents 多态Table of contents多态的优点多态存在的三个必要条件 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 Test.java public class Test { public static void main(String[] args) { show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work } public static void show(Animal a) { a.eat(); // 类型判断 if (a instanceof Cat) { // 猫做的事情 Cat c = (Cat)a; c.work(); } else if (a instanceof Dog) { // 狗做的事情 Dog c = (Dog)a; c.work(); } } } abstract class Animal { abstract void eat(); } class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } public void work() { System.out.println(\"抓老鼠\"); } } class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } public void work() { System.out.println(\"看家\"); } } "},"02-面向对象/04-抽象类.html":{"url":"02-面向对象/04-抽象类.html","title":"抽象类","keywords":"","body":"抽象类Table of contents此处应该有栗子抽象方法抽象类总结规定抽象类 在面向对象的概念中, 所有的对象都是通过类来描绘的, 但是反过来, 并不是所有的类都是用来描绘对象的, 如果一个类中没有包含足够的信息来描绘一个具体的东西, 这样的类就是抽象类. 抽象类除了不能实例化对象之外, 类的其它功能依然存在, 成员变量, 成员方法和构造方法的访问方式和普通类一样. 由于抽象类不能实例化对象, 所以抽象类必须被继承, 才能被使用. 也是因为这个原因, 通常在设计阶段决定要不要涉及抽象类. 父类包含了子类集合的常见方法, 但是由于父类本身是抽象的, 所以不能使用这些方法. 在Java中抽象类表示的是一种继承关系, 一个类智能继承一个抽象类, 而一个类却可以实现多个接口 Table of contents 抽象类Table of contents此处应该有栗子抽象方法抽象类总结规定 此处应该有栗子 抽象方法 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 public abstract class Employee { private String name; private String address; private int number; public abstract double computePay(); //其余代码 } 声明抽象方法会造成以下两个结果 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法 /* 文件名 : Salary.java */ public class Salary extends Employee { private double salary; // Annual salary public double computePay() { System.out.println(\"Computing salary pay for \" + getName()); return salary/52; } //其余代码 } 抽象类总结规定 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 "},"02-面向对象/05-封装.html":{"url":"02-面向对象/05-封装.html","title":"封装","keywords":"","body":"封装Table of contents实现Java封装的步骤封装 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 Table of contents 封装Table of contents实现Java封装的步骤 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： public class Person { private String name; private int age; } 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： public class Person{ private String name; private int age; ​ public int getAge(){ return age; } ​ public String getName(){ return name; } ​ public void setAge(int age){ this.age = age; } ​ public void setName(String name){ this.name = name; } } 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 "},"02-面向对象/06-接口.html":{"url":"02-面向对象/06-接口.html","title":"接口","keywords":"","body":"接口Table of contents接口与类相似点接口与类的区别接口特性抽象类和接口的区别接口的声明接口的实现接口的继承接口的多继承标记接口接口 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 Table of contents 接口Table of contents接口与类相似点接口与类的区别接口特性抽象类和接口的区别接口的声明接口的实现接口的继承接口的多继承标记接口 接口与类相似点 一个接口可以有多个方法 接口文件保存在.java结尾的文件中, 文件名使用接口名 接口的字节码文件保存在.class结尾的文件中 接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口不能包含成员变量, 除了static和final变量 接口不是被类继承, 而是要被类实现 接口支持多继承 接口特性 接口中每一个方法也是隐式抽象的, 接口中的方法会被隐式的指定为public abstract(只能是public abstract, 其他修饰符都会报错) 接口中可以含有变量, 但是接口中的变量会被隐式的指定为public static final变量(并且只能是public, 用private修饰会报编译错误) 接口中的方法是不能再接口中实现的, 只能由实现接口的类来实现接口中的方法 抽象类和接口的区别 抽象类中的方法可以有方法体, 就是能实现方法的具体功能, 但是接口中的方法不行 抽象类中的成员变量可以是各种类型的, 而接口中的成员变量只能是public static final类型的 接口总不能含有静态代码以及静态方法(用static修饰的方法), 而抽象类是可以有静态代码块和静态方法 一个类只能继承一个抽象类, 而一个类却可以实现多个接口 接口的声明 语法格式 [可见度] interface 接口名称 [extends 其他的类名] { // 声明变量 // 抽象方法 } interface关键字用来声明一个接口 实例 /* 文件名 : NameOfInterface.java */ import java.lang.*; //引入包 public interface NameOfInterface { //任何类型 final, static 字段 //抽象方法 } 接口有以下特性 接口是隐式抽象的, 当声明一个接口的时候, 不必使用abstract关键字 接口中灭一个方法也是隐式抽象的, 声明时同样不需要abstract关键字 接口中的方法都是公有的 实例 /* 文件名 : Animal.java */ interface Animal { public void eat(); public void travel(); } 接口的实现 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： Animal.java ...implements 接口名称[, 其他接口, 其他接口..., ...] ... 实例 /* 文件名 : MammalInt.java */ public class MammalInt implements Animal{ public void eat(){ System.out.println(\"Mammal eats\"); } public void travel(){ System.out.println(\"Mammal travels\"); } public int noOfLegs(){ return 0; } public static void main(String args[]){ MammalInt m = new MammalInt(); m.eat(); m.travel(); } } 编译运行结果如下 Mammal eats Mammal travels 重写接口中声明的方法时, 需要注意一下规则 类在实现接口的方法时, 不能抛出强制性异常, 只能在接口中, 或者继承接口的抽象类中抛出该强制性异常 类在重写方法时要保持一致的方法名, 并且应该保持相同或者相兼容的返回值类型 如果实现接口的类是抽象类, 那么就没必要实现该接口的方法 在实现接口的时候, 也要注意一些规则 一个类可以实现多个接口 一个类只能继承一个类, 但是能实现多个接口 一个接口能继承另一个接口, 这和类之间的继承比较相似 接口的继承 一个接口能继承另一个接口, 和类之间的继承方式比较相似. 接口的继承使用extends关键字, 子接口继承父接口的方法 下面的Sports接口被Hockey和Football接口继承： // 文件名: Sports.java public interface Sports { public void setHomeTeam(String name); public void setVisitingTeam(String name); } // 文件名: Football.java public interface Football extends Sports { public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter); } // 文件名: Hockey.java public interface Hockey extends Sports { public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot); } Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多继承 在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法 标记接口 最常用的继承接口是没有包含任何方法的接口。 标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： package java.util; public interface EventListener {} 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的 建立一个公共的父接口 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 "},"02-面向对象/07-包.html":{"url":"02-面向对象/07-包.html","title":"包","keywords":"","body":"包(package)Table of contents包的作用创建包importpackage的目录结构设置 CLASSPATH 系统变量包(package) 为了更好地组织类, Java提供了包机制, 用于区别类名的命名空间 Table of contents 包(package)Table of contents包的作用创建包importpackage的目录结构设置 CLASSPATH 系统变量 包的作用 把功能相似或相关的类或接口组织在同一个包中, 方便类的查找和使用 如同文件夹一样, 包也采用树形目录的存储方式. 同一个包中的类名字是不同的, 不同的包中的类的名字是可以相同的, 当同时调用两个不同包中相同类名的类时, 应该加上包名加以区别. 因此, 包可以避免名字冲突. 包也限定了访问权限, 拥有包访问权限的类才能访问某个包中的类 Java 使用包（package）这种机制是为了防止命名冲突, 访问控制, 提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 语法格式 package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容 package net.java.util public class Something{ ... } 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存, 更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释）, 为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang: 打包基础的类 java.io: 包含输入输出功能的函数 开发者可以自己把一组类和接口等打包, 并定义自己的包。而且在实际开发中这样做是值得提倡的, 当你自己完成类的实现之后, 将相关的类分组, 可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace）, 所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制, 更容易实现访问控制, 并且让定位相关类更加简单。 创建包 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子 创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： Animal.java /* 文件名: Animal.java */ package animals; interface Animal { public void eat(); public void travel(); } 接下来，在同一个包中加入该接口的实现： MammalInt.java package animals; /* 文件名 : MammalInt.java */ public class MammalInt implements Animal{ public void eat(){ System.out.println(\"Mammal eats\"); } public void travel(){ System.out.println(\"Mammal travels\"); } public int noOfLegs(){ return 0; } public static void main(String args[]){ MammalInt m = new MammalInt(); m.eat(); m.travel(); } } 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行： $ mkdir animals $ cp Animal.class MammalInt.class animals $ java animals/MammalInt Mammal eats Mammal travel import 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 \"import\" 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 例子 下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。 // Boss.java 文件代码： package payroll; public class Boss { public void payEmployee(Employee e) { e.mailCheck(); } } 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。 使用类全名描述，例如： payroll.Employee 用 import 关键字引入，使用通配符 \"*\" import payroll.*; 使用 import 关键字引入 Employee 类: import payroll.Employee; 注意 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 package的目录结构 类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 下面是管理你自己 java 中文件的一种简单方式： 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如： // 文件名 : Car.java package vehicle; public class Car { // 类实现 } 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。 ....\\vehicle\\Car.java 现在，正确的类名和路径将会是如下样子： 类名 -> vehicle.Car 路径名 -> vehicle\\Car.java (在 windows 系统中) 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录： ....\\com\\runoob\\test\\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： // 文件名: Runoob.java package com.runoob.test; public class Runoob { } class Google { } 现在，我们用-d选项来编译这个文件，如下： javac -d . Runoob.java 这样会像下面这样放置编译了的文件： .\\com\\runoob\\test\\Runoob.class .\\com\\runoob\\test\\Google.class 你可以像下面这样来导入所有 \\com\\runoob\\test\\ 中定义的类、接口等： import com.runoob.test.*; 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。 \\sources\\com\\runoob\\test\\Runoob.java \\classes\\com\\runoob\\test\\Google.class 这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 \\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 \\classes\\com\\runoob\\test 中找 .class 文件。 一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。 设置 CLASSPATH 系统变量 用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:\\> set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH 删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:\\> set CLASSPATH= UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:\\> set CLASSPATH=C:\\users\\jack\\java\\classes UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH "},"02-面向对象/tmp.html":{"url":"02-面向对象/tmp.html","title":"tmp","keywords":"","body":"tmpTable of contents向上造型tmp Table of contents tmpTable of contents向上造型 向上造型 子类的对象可以向上造型为父类的类型。即父类引用子类对象，这种方式被称为向上造型。 "},"03-高级教程/":{"url":"03-高级教程/","title":"高级教程","keywords":"","body":"高级教程高级教程 "},"03-高级教程/01-数据结构.html":{"url":"03-高级教程/01-数据结构.html","title":"数据结构","keywords":"","body":"数据结构数据结构 Java工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类： 枚举（Enumeration） 位集合（BitSet） 向量（Vector） 栈（Stack） 字典（Dictionary） 哈希表（Hashtable） 属性（Properties） 以上这些类是传统遗留的，在Java2中引入了一种新的框架-集合框架(Collection)。 "},"03-高级教程/02-集合框架.html":{"url":"03-高级教程/02-集合框架.html","title":"集合框架","keywords":"","body":"集合框架Table of contents使用迭代器遍历 ArrayList遍历 Map如何使用比较器总结集合框架 早在Java 2中之前，Java就提供了特设类。比如：Dictionary, Vector, Stack, 和Properties这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用Vector类的方式和使用Properties类的方式有着很大不同。 集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet等,除此之外你也可以通过这些接口实现自己的集合。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个Map接口和类。Map里存储的是键值对。尽管Map不是collections，但是它们完全整合在集合中。 Table of contents 集合框架Table of contents使用迭代器遍历 ArrayList遍历 Map如何使用比较器总结 使用迭代器 通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。 一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。 迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。 使用 Java Iterator 这里通过实例列出Iterator和listIterator接口提供的所有方法。 遍历 ArrayList 实例 import java.util.*; public class Test{ public static void main(String[] args) { List list=new ArrayList(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"HAHAHAHA\"); //第一种遍历方法使用foreach遍历List for (String str : list) { //也可以改写for(int i=0;i ite=list.iterator(); while(ite.hasNext())//判断下一个元素之后有值 { System.out.println(ite.next()); } } } 三种方法都是用来遍历ArrayList集合，第三种方法是采用迭代器的方法，该方法可以不用担心在遍历的过程中会超出集合的长度。 遍历 Map 实例 import java.util.*; public class Test{ public static void main(String[] args) { Map map = new HashMap(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator> it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } } } 如何使用比较器 TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序。 这个接口可以让我们以不同的方式来排序一个集合。 使用 Java Comparator 总结 Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 "},"03-高级教程/03-泛型.html":{"url":"03-高级教程/03-泛型.html","title":"泛型","keywords":"","body":"泛型Table of contents泛型方法泛型类类型通配符通配符T,E,K,Vee泛型 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制, 该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型, 也就是说所操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法, 能够对整型数组、字符串数组甚至其他任何类型的数组进行排序, 该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念, 我们可以写一个泛型方法来对一个对象数组排序。然后, 调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 Table of contents 泛型Table of contents泛型方法泛型类类型通配符通配符T,E,K,Vee 泛型方法 你可以写一个泛型方法, 该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型, 编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔）, 该类型参数声明部分在方法返回类型之前（在下面例子中的）。 每一个类型参数声明部分包含一个或多个类型参数, 参数间用逗号隔开。一个泛型参数, 也被称为一个类型变量, 是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型, 并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型, 不能是原始类型（像int,double,char的等）。 实例 下面的例子演示了如何使用泛型方法打印不同字符串的元素： public class GenericMethodTest { // 泛型方法 printArray public static void printArray( E[] inputArray ) { // 输出数组元素 for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } public static void main( String args[] ) { // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = { 1, 2, 3, 4, 5 }; Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { 'H', 'E', 'L', 'L', 'O' }; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型数组 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 } } 编译以上代码, 运行结果如下所示： 整型数组元素为: 1 2 3 4 5 双精度型数组元素为: 1.1 2.2 3.3 4.4 字符型数组元素为: H E L L O 有界的类型参数: 可能有时候, 你会想限制那些被允许传递到一个类型参数的类型种类范围。例如, 一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。 要声明一个有界的类型参数, 首先列出类型参数的名称, 后跟extends关键字, 最后紧跟它的上界。 实例 下面的例子演示了\"extends\"如何使用在一般意义上的意思\"extends\"（类）或者\"implements\"（接口）。该例子中的泛型方法返回三个可比较对象的最大值。 public class MaximumTest { // 比较三个值并返回最大值 public static > T maximum(T x, T y, T z) { T max = x; // 假设x是初始最大值 if ( y.compareTo( max ) > 0 ){ max = y; //y 更大 } if ( z.compareTo( max ) > 0 ){ max = z; // 现在 z 更大 } return max; // 返回最大对象 } public static void main( String args[] ) { System.out.printf( \"%d, %d 和 %d 中最大的数为 %d\\n\\n\", 3, 4, 5, maximum( 3, 4, 5 ) ); System.out.printf( \"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\", 6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); System.out.printf( \"%s, %s 和 %s 中最大的数为 %s\\n\",\"pear\", \"apple\", \"orange\", maximum( \"pear\", \"apple\", \"orange\" ) ); } } 编译以上代码, 运行结果如下所示 3, 4 和 5 中最大的数为 5 6.6, 8.8 和 7.7 中最大的数为 8.8 pear, apple 和 orange 中最大的数为 pear 泛型类 泛型类的声明和非泛型类的声明类似, 除了在类名后面添加了类型参数声明部分。 和泛型方法一样, 泛型类的类型参数声明部分也包含一个或多个类型参数, 参数间用逗号隔开。一个泛型参数, 也被称为一个类型变量, 是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数, 这些类被称为参数化的类或参数化的类型。 实例 如下实例演示了我们如何定义一个泛型类: public class Box { private T t; public void add(T t) { this.t = t; } public T get() { return t; } public static void main(String[] args) { Box integerBox = new Box(); Box stringBox = new Box(); integerBox.add(new Integer(10)); stringBox.add(new String(\"菜鸟教程\")); System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get()); System.out.printf(\"字符串为 :%s\\n\", stringBox.get()); } } 编译以上代码, 运行结果如下所示 整型值为 :10 字符串为 :菜鸟教程 类型通配符 通配符T,E,K,V 这些全都属于java泛型的通配符, 这几个其实没什么区别, 只不过是一个约定好的代码, 也就是说, 使用大写字母A,B,C,D......X,Y,Z定义的, 就都是泛型, 把T换成A也一样, 这里T只是名字上的意义而已 ? 表示不确定的java类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element ee 类型通配符一般是使用?代替具体的类型参数。例如 List 在逻辑上是List,List 等所有List的父类。 public class GenericTest { public static void main(String[] args) { List name = new ArrayList(); List age = new ArrayList(); List number = new ArrayList(); name.add(\"icon\"); age.add(18); number.add(314); getData(name); getData(age); getData(number); } public static void getData(List data) { System.out.println(\"data :\" + data.get(0)); } } 输出结果为 data :icon data :18 data :314 解析： 因为getDate()方法的参数是List类型的, 所以name, age, number都可以作为这个方法的实参, 这就是通配符的作用 类型通配符上限通过形如List来定义, 如此定义就是通配符泛型值接受Number及其下层子类类型。 public class GenericTest { public static void main(String[] args) { List name = new ArrayList(); List age = new ArrayList(); List number = new ArrayList(); name.add(\"icon\"); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 } public static void getData(List data) { System.out.println(\"data :\" + data.get(0)); } public static void getUperNumber(List data) { System.out.println(\"data :\" + data.get(0)); } } 输出结果： data :18 data :314 解析： 在(//1)处会出现错误, 因为getUperNumber()方法中的参数已经限定了参数泛型上限为Number, 所以泛型为String是不在这个范围之内, 所以会报错 类型通配符下限通过形如 List来定义, 表示类型只能接受Number及其三层父类类型, 如Object类型的实例。 "},"03-高级教程/04-序列化.html":{"url":"03-高级教程/04-序列化.html","title":"序列化","keywords":"","body":"序列化Table of contents序列化对象反序列化对象序列化 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象, 并将对象反序列化. 它的返回值为Object, 因此, 你需要将它转换成合适的数据类型 为了演示序列化在Java中是怎样工作的，我将使用之前教程中提到的Employee类，假设我们定义了如下的Employee类，该类实现了Serializable 接口。 Employee.java 文件代码 public class Employee implements java.io.Serializable { public String name; public String address; public transient int SSN; public int number; public void mailCheck() { System.out.println(\"Mailing a check to \" + name + \" \" + address); } } 请注意，一个类的对象要想序列化成功，必须满足两个条件： 该类必须实现 java.io.Serializable 对象。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。 Table of contents 序列化Table of contents序列化对象反序列化对象 序列化对象 ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。 该程序执行后，就创建了一个名为 employee.ser 文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。 注意： 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。 SerializeDemo.java 文件代码： import java.io.*; public class SerializeDemo { public static void main(String [] args) { Employee e = new Employee(); e.name = \"Reyan Ali\"; e.address = \"Phokka Kuan, Ambehta Peer\"; e.SSN = 11122333; e.number = 101; try { FileOutputStream fileOut = new FileOutputStream(\"/tmp/employee.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf(\"Serialized data is saved in /tmp/employee.ser\"); }catch(IOException i) { i.printStackTrace(); } } } 反序列化对象 下面的 DeserializeDemo 程序实例了反序列化，/tmp/employee.ser 存储了 Employee 对象。 DeserializeDemo.java 文件代码 import java.io.*; public class DeserializeDemo { public static void main(String [] args) { Employee e = null; try { FileInputStream fileIn = new FileInputStream(\"/tmp/employee.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println(\"Employee class not found\"); c.printStackTrace(); return; } System.out.println(\"Deserialized Employee...\"); System.out.println(\"Name: \" + e.name); System.out.println(\"Address: \" + e.address); System.out.println(\"SSN: \" + e.SSN); System.out.println(\"Number: \" + e.number); } } 以上程序编译运行结果如下所示 Deserialized Employee... Name: Reyan Ali Address:Phokka Kuan, Ambehta Peer SSN: 0 Number:101 这里要注意以下要点 readObject() 方法中的 try/catch 代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 注意，readObject() 方法的返回值被转化成 Employee 引用。 当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。 "},"03-高级教程/05-网络编程.html":{"url":"03-高级教程/05-网络编程.html","title":"网络编程","keywords":"","body":"网络编程Table of contentsSocket 编程ServerSocket 类的方法Socket 类的方法InetAddress 类的方法Socket 客户端实例Socket 服务端实例网络编程 网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。 URL 处理：这部分会在另外的篇幅里讲，点击这里更详细地了解在 Java 语言中的 URL 处理。 Table of contents 网络编程Table of contentsSocket 编程ServerSocket 类的方法Socket 类的方法InetAddress 类的方法Socket 客户端实例Socket 服务端实例 Socket 编程 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。 TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。 ServerSocket 类的方法 服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 ServerSocket 类有四个构造方法： 序号 方法描述 1 public ServerSocket(int port) throws IOException创建绑定到特定端口的服务器套接字。 2 public ServerSocket(int port, int backlog) throws IOException利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。 3 public ServerSocket(int port, int backlog, InetAddress address) throws IOException使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。 4 public ServerSocket() throws IOException创建非绑定服务器套接字。 创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。 这里有一些 ServerSocket 类的常用方法： 序号 方法描述 1 public int getLocalPort()返回此套接字在其上侦听的端口。 2 public Socket accept() throws IOException侦听并接受到此套接字的连接。 3 public void setSoTimeout(int timeout)通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。 4 public void bind(SocketAddress host, int backlog)将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 Socket 类的方法 java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 Socket 类有五个构造方法. 序号 方法描述 1 public Socket(String host, int port) throws UnknownHostException, IOException.创建一个流套接字并将其连接到指定主机上的指定端口号。 2 public Socket(InetAddress host, int port) throws IOException创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.创建一个套接字并将其连接到指定远程主机上的指定远程端口。 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.创建一个套接字并将其连接到指定远程地址上的指定远程端口。 5 public Socket()通过系统默认类型的 SocketImpl 创建未连接套接字 当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。 下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。 序号 方法描述 1 public void connect(SocketAddress host, int timeout) throws IOException将此套接字连接到服务器，并指定一个超时值。 2 public InetAddress getInetAddress() 返回套接字连接的地址。 3 public int getPort()返回此套接字连接到的远程端口。 4 public int getLocalPort()返回此套接字绑定到的本地端口。 5 public SocketAddress getRemoteSocketAddress()返回此套接字连接的端点的地址，如果未连接则返回 null。 6 public InputStream getInputStream() throws IOException返回此套接字的输入流。 7 public OutputStream getOutputStream() throws IOException返回此套接字的输出流。 8 public void close() throws IOException关闭此套接字。 InetAddress 类的方法 这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法： 序号 方法描述 1 static InetAddress getByAddress(byte[] addr)在给定原始 IP 地址的情况下，返回 InetAddress 对象。 2 static InetAddress getByAddress(String host, byte[] addr)根据提供的主机名和 IP 地址创建 InetAddress。 3 static InetAddress getByName(String host)在给定主机名的情况下确定主机的 IP 地址。 4 String getHostAddress() 返回 IP 地址字符串（以文本表现形式）。 5 String getHostName() 获取此 IP 地址的主机名。 6 static InetAddress getLocalHost()返回本地主机。 7 String toString()将此 IP 地址转换为 String。 Socket 客户端实例 如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。 // 文件名 GreetingClient.java import java.net.*; import java.io.*; public class GreetingClient { public static void main(String [] args) { String serverName = args[0]; int port = Integer.parseInt(args[1]); try { System.out.println(\"连接到主机：\" + serverName + \" ，端口号：\" + port); Socket client = new Socket(serverName, port); System.out.println(\"远程主机地址：\" + client.getRemoteSocketAddress()); OutputStream outToServer = client.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); out.writeUTF(\"Hello from \" + client.getLocalSocketAddress()); InputStream inFromServer = client.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println(\"服务器响应： \" + in.readUTF()); client.close(); }catch(IOException e) { e.printStackTrace(); } } } Socket 服务端实例 如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。 // 文件名 GreetingServer.java import java.net.*; import java.io.*; public class GreetingServer extends Thread { private ServerSocket serverSocket; public GreetingServer(int port) throws IOException { serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); } public void run() { while(true) { try { System.out.println(\"等待远程连接，端口号为：\" + serverSocket.getLocalPort() + \"...\"); Socket server = serverSocket.accept(); System.out.println(\"远程主机地址：\" + server.getRemoteSocketAddress()); DataInputStream in = new DataInputStream(server.getInputStream()); System.out.println(in.readUTF()); DataOutputStream out = new DataOutputStream(server.getOutputStream()); out.writeUTF(\"谢谢连接我：\" + server.getLocalSocketAddress() + \"\\nGoodbye!\"); server.close(); }catch(SocketTimeoutException s) { System.out.println(\"Socket timed out!\"); break; }catch(IOException e) { e.printStackTrace(); break; } } } public static void main(String [] args) { int port = Integer.parseInt(args[0]); try { Thread t = new GreetingServer(port); t.run(); }catch(IOException e) { e.printStackTrace(); } } } 编译以上两个 java 文件代码，并执行以下命令来启动服务，使用端口号为 6066： $ javac GreetingServer.java $ java GreetingServer 6066 等待远程连接，端口号为：6066... 新开一个命令窗口，执行以上命令来开启客户端： $ javac GreetingClient.java $ java GreetingClient localhost 6066 连接到主机：localhost ，端口号：6066 远程主机地址：localhost/127.0.0.1:6066 服务器响应： 谢谢连接我：/127.0.0.1:6066 Goodbye! "},"03-高级教程/06-发送邮件.html":{"url":"03-高级教程/06-发送邮件.html","title":"发送邮件","keywords":"","body":"发送邮件Table of contents发送简单的E-mail发送一封 HTML E-mail发送带有附件的 E-mail用户认证部分发送邮件 使用Java应用程序发送 E-mail 十分简单，但是首先你应该在你的机器上安装 JavaMail API 和Java Activation Framework (JAF) 。 您可以从 Java 网站下载最新版本的 JavaMail，打开网页右侧有个 Downloads 链接，点击它下载。 您可以从 Java 网站下载最新版本的 JAF（版本 1.1.1）。 你也可以使用本站提供的下载链接： JavaMail mail.jar 1.4.5 JAF（版本 1.1.1） activation.jar 下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。您需要把 mail.jar 和 activation.jar文件添加到您的 CLASSPATH 中。 如果你使用第三方邮件服务器如QQ的SMTP服务器，可查看文章底部用户认证完整的实例。 Table of contents 发送邮件Table of contents发送简单的E-mail发送一封 HTML E-mail发送带有附件的 E-mail用户认证部分 发送简单的E-mail 下面是一个发送简单E-mail的例子。假设你的localhost已经连接到网络。 // 文件名 SendEmail.java import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*; public class SendEmail { public static void main(String [] args) { // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认session对象 Session session = Session.getDefaultInstance(properties); try{ // 创建默认的 MimeMessage 对象 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is actual message\"); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); }catch (MessagingException mex) { mex.printStackTrace(); } } } 编译并运行这个程序来发送一封简单的E-mail： $ java SendEmail Sent message successfully.... 如果你想发送一封e-mail给多个收件人，那么使用下面的方法来指定多个收件人ID： void addRecipients(Message.RecipientType type, Address[] addresses)throws MessagingException 下面是对于参数的描述 type:要被设置为 TO, CC 或者 BCC，这里 CC 代表抄送、BCC 代表秘密抄送。举例：Message.RecipientType.TO addresses: 这是 email ID 的数组。在指定电子邮件 ID 时，你将需要使用 InternetAddress() 方法。 发送一封 HTML E-mail 下面是一个发送 HTML E-mail 的例子。假设你的 localhost 已经连接到网络。 和上一个例子很相似，除了我们要使用 setContent() 方法来通过第二个参数为 \"text/html\"，来设置内容来指定要发送HTML 内容。 // 文件名 SendHTMLEmail.java import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*; public class SendHTMLEmail { public static void main(String [] args) { // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认的 Session 对象。 Session session = Session.getDefaultInstance(properties); try{ // 创建默认的 MimeMessage 对象。 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头字段 message.setSubject(\"This is the Subject Line!\"); // 发送 HTML 消息, 可以插入html标签 message.setContent(\"This is actual message\", \"text/html\" ); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); }catch (MessagingException mex) { mex.printStackTrace(); } } } 编译并运行此程序来发送HTML e-mail： $ java SendHTMLEmail Sent message successfully.... 发送带有附件的 E-mail // 文件名 SendFileEmail.java import java.util.*; import javax.mail.*; import javax.mail.internet.*; import javax.activation.*; public class SendFileEmail { public static void main(String [] args) { // 收件人电子邮箱 String to = \"abcd@gmail.com\"; // 发件人电子邮箱 String from = \"web@gmail.com\"; // 指定发送邮件的主机为 localhost String host = \"localhost\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认的 Session 对象。 Session session = Session.getDefaultInstance(properties); try{ // 创建默认的 MimeMessage 对象。 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头字段 message.setSubject(\"This is the Subject Line!\"); // 创建消息部分 BodyPart messageBodyPart = new MimeBodyPart(); // 消息 messageBodyPart.setText(\"This is message body\"); // 创建多重消息 Multipart multipart = new MimeMultipart(); // 设置文本消息部分 multipart.addBodyPart(messageBodyPart); // 附件部分 messageBodyPart = new MimeBodyPart(); String filename = \"file.txt\"; DataSource source = new FileDataSource(filename); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(filename); multipart.addBodyPart(messageBodyPart); // 发送完整消息 message.setContent(multipart ); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....\"); }catch (MessagingException mex) { mex.printStackTrace(); } } } 编译并运行 用户认证部分 如果需要提供用户名和密码给e-mail服务器来达到用户认证的目的，你可以通过如下设置来完成： props.put(\"mail.smtp.auth\", \"true\"); props.setProperty(\"mail.user\", \"myuser\"); props.setProperty(\"mail.password\", \"mypwd\"); 实例 // 需要用户名密码邮件发送实例 //文件名 SendEmail2.java //本实例以QQ邮箱为例，你需要在qq后台设置 import java.util.Properties; import javax.mail.Authenticator; import javax.mail.Message; import javax.mail.MessagingException; import javax.mail.PasswordAuthentication; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class SendEmail2 { public static void main(String [] args) { // 收件人电子邮箱 String to = \"xxx@qq.com\"; // 发件人电子邮箱 String from = \"xxx@qq.com\"; // 指定发送邮件的主机为 smtp.qq.com String host = \"smtp.qq.com\"; //QQ 邮件服务器 // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); properties.put(\"mail.smtp.auth\", \"true\"); // 获取默认session对象 Session session = Session.getDefaultInstance(properties,new Authenticator(){ public PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(\"xxx@qq.com\", \"qq邮箱密码\"); //发件人邮件用户名、密码 } }); try{ // 创建默认的 MimeMessage 对象 MimeMessage message = new MimeMessage(session); // Set From: 头部头字段 message.setFrom(new InternetAddress(from)); // Set To: 头部头字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // Set Subject: 头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is actual message\"); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully....from runoob.com\"); }catch (MessagingException mex) { mex.printStackTrace(); } } } "},"03-高级教程/07-多线程编程.html":{"url":"03-高级教程/07-多线程编程.html","title":"多线程编程","keywords":"","body":"多线程编程Table of contents一个线程的生命周期线程的优先级创建一个线程通过实现 Runnable 接口来创建线程通过继承Thread来创建线程Thread 方法实例创建线程的三种方式的对比线程的几个主要概念多线程的使用多线程编程 Java 给多线程编程提供了内置的支持。一个多线程程序包含两个或多个能并发运行的部分。程序的每一部分都称作一个线程，并且每个线程定义了一个独立的执行路径。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 Table of contents 多线程编程Table of contents一个线程的生命周期线程的优先级创建一个线程通过实现 Runnable 接口来创建线程通过继承Thread来创建线程Thread 方法实例创建线程的三种方式的对比线程的几个主要概念多线程的使用 一个线程的生命周期 线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建一个线程 Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过实现 Runnable 接口来创建线程 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 void start(); 下面是一个创建线程并开始让它执行的实例： class RunnableDemo implements Runnable { private Thread t; private String threadName; RunnableDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i > 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } } } public class TestThread { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 编译以上程序运行结果如下： Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. 通过继承Thread来创建线程 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 class ThreadDemo extends Thread { private Thread t; private String threadName; ThreadDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i > 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡醒一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } } } public class TestThread { public static void main(String args[]) { ThreadDemo T1 = new ThreadDemo( \"Thread-1\"); T1.start(); ThreadDemo T2 = new ThreadDemo( \"Thread-2\"); T2.start(); } } 编译以上程序运行结果如下： Creating Thread-1 Starting Thread-1 Creating Thread-2 Starting Thread-2 Running Thread-1 Thread: Thread-1, 4 Running Thread-2 Thread: Thread-2, 4 Thread: Thread-1, 3 Thread: Thread-2, 3 Thread: Thread-1, 2 Thread: Thread-2, 2 Thread: Thread-1, 1 Thread: Thread-2, 1 Thread Thread-1 exiting. Thread Thread-2 exiting. Thread 方法 下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start()使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run()如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name)改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。 6 public final void join(long millisec)等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt()中断线程。 8 public final boolean isAlive()测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 public static void yield()暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec)在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x)当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread()返回对当前正在执行的线程对象的引用。 5 public static void dumpStack()将当前线程的堆栈跟踪打印至标准错误流。 实例 如下的ThreadClassDemo 程序演示了Thread类的一些方法： // 文件名 : DisplayMessage.java // 通过实现 Runnable 接口创建线程 public class DisplayMessage implements Runnable { private String message; public DisplayMessage(String message) { this.message = message; } public void run() { while(true) { System.out.println(message); } } } // 文件名 : GuessANumber.java // 通过继承 Thread 类创建线程 public class GuessANumber extends Thread { private int number; public GuessANumber(int number) { this.number = number; } public void run() { int counter = 0; int guess = 0; do { guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + \" guesses \" + guess); counter++; } while(guess != number); System.out.println(\"** Correct!\" + this.getName() + \"in\" + counter + \"guesses.**\"); } } // 文件名 : ThreadClassDemo.java public class ThreadClassDemo { public static void main(String [] args) { Runnable hello = new DisplayMessage(\"Hello\"); Thread thread1 = new Thread(hello); thread1.setDaemon(true); thread1.setName(\"hello\"); System.out.println(\"Starting hello thread...\"); thread1.start(); Runnable bye = new DisplayMessage(\"Goodbye\"); Thread thread2 = new Thread(bye); thread2.setPriority(Thread.MIN_PRIORITY); thread2.setDaemon(true); System.out.println(\"Starting goodbye thread...\"); thread2.start(); System.out.println(\"Starting thread3...\"); Thread thread3 = new GuessANumber(27); thread3.start(); try { thread3.join(); }catch(InterruptedException e) { System.out.println(\"Thread interrupted.\"); } System.out.println(\"Starting thread4...\"); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println(\"main() is ending...\"); } } 运行结果如下，每一次运行的结果都不一样。 Starting hello thread... Starting goodbye thread... Hello Hello Hello Hello Hello Hello Goodbye Goodbye Goodbye Goodbye Goodbye ....... 通过 Callable 和 Future 创建线程 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 public class CallableThreadTest implements Callable { public static void main(String[] args) { CallableThreadTest ctt = new CallableThreadTest(); FutureTask ft = new FutureTask<>(ctt); for(int i = 0;i 创建线程的三种方式的对比 采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个主要概念 在多线程编程时，你需要了解以下几个概念： 线程同步 线程间通信 线程死锁 线程控制：挂起、停止和恢复 多线程的使用 有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。 请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！ "},"03-高级教程/08-JVM.html":{"url":"03-高级教程/08-JVM.html","title":"JVM","keywords":"","body":"JVMJVM https://segmentfault.com/a/1190000002579346 "},"03-高级教程/09-Collections.html":{"url":"03-高级教程/09-Collections.html","title":"Collections","keywords":"","body":"CollectionsTable of contentsCollection和Collections的区别常见的几个小方法案例Collection集合总结在集合中常见的数据结构(掌握)针对Collection集合我们到底使用谁Collections 是针对集合进行操作的工具类 Table of contents CollectionsTable of contentsCollection和Collections的区别常见的几个小方法案例Collection集合总结在集合中常见的数据结构(掌握)针对Collection集合我们到底使用谁 Collection和Collections的区别 Collection 是单列集合的顶层接口，有两个子接口List和Set Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等 常见的几个小方法 public static void sort(List list) public static int binarySearch(List list,T key) public static T max(Collection coll) public static void reverse(List list) public static void shuffle(List list) 案例 ArrayList集合存储自定义对象的排序 模拟斗地主洗牌和发牌 模拟斗地主洗牌和发牌并对牌进行排序 Collection集合总结 Collection |--List 有序,可重复 |--ArrayList 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高 |--Vector 底层数据结构是数组，查询快，增删慢。 线程安全，效率低 |--LinkedList 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高 |--Set 无序,唯一 |--HashSet 底层数据结构是哈希表。 如何保证元素唯一性的呢? 依赖两个方法：hashCode()和equals() 开发中自动生成这两个方法即可 |--LinkedHashSet 底层数据结构是链表和哈希表 由链表保证元素有序 由哈希表保证元素唯一 |--TreeSet 底层数据结构是红黑树。 如何保证元素排序的呢? 自然排序 比较器排序 如何保证元素唯一性的呢? 根据比较的返回值是否是0来决定 在集合中常见的数据结构(掌握) ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序 针对Collection集合我们到底使用谁 是否唯一 是：Set 排序吗? 是：TreeSet 否：HashSet 如果你知道是Set，但是不知道是哪个Set，就用HashSet。 否：List 要安全吗? 是：Vector 否：ArrayList或者LinkedList 查询多：ArrayList 增删多：LinkedList 如果你知道是List，但是不知道是哪个List，就用ArrayList。 如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。 如果你知道用集合，就用ArrayList。 "},"03-高级教程/10-Map.html":{"url":"03-高级教程/10-Map.html","title":"Map","keywords":"","body":"MapTable of contentsMap和Collection的区别Map功能概述(待补齐)Map集合的遍历键找值键值对对象找键和值HashMap集合(常用)TreeMap集合的练习案例统计一个字符串中每个字符出现的次数集合的嵌套遍历Map 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Table of contents MapTable of contentsMap和Collection的区别Map功能概述(待补齐)Map集合的遍历键找值键值对对象找键和值HashMap集合(常用)TreeMap集合的练习案例统计一个字符串中每个字符出现的次数集合的嵌套遍历 Map和Collection的区别 Map 存储的是键值对形式的元素，键唯一，值可以重复。夫妻对 Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。 Map功能概述(待补齐) 添加功能 删除功能 判断功能 获取功能 长度功能 Map集合的遍历 键找值 获取所有键的集合 遍历键的集合,得到每一个键 根据键到集合中去找值 键值对对象找键和值 获取所有的键值对对象的集合 遍历键值对对象的集合，获取每一个键值对对象 根据键值对对象去获取键和值 代码体现： Map hm = new HashMap(); hm.put(\"it002\",\"hello\"); hm.put(\"it003\",\"world\"); hm.put(\"it001\",\"java\"); //方式1 键找值 Set set = hm.keySet(); for(String key : set) { String value = hm.get(key); System.out.println(key+\"---\"+value); } //方式2 键值对对象找键和值 Set> set2 = hm.entrySet(); for(Map.Entry me : set2) { String key = me.getKey(); String value = me.getValue(); System.out.println(key+\"---\"+value); } HashMap集合(常用) HashMap HashMap HashMap HashMap TreeMap集合的练习 TreeMap TreeMap 案例 统计一个字符串中每个字符出现的次数 集合的嵌套遍历 HashMap嵌套HashMap HashMap嵌套ArrayList ArrayList嵌套HashMap 多层嵌套 "},"03-高级教程/11-Set.html":{"url":"03-高级教程/11-Set.html","title":"Set","keywords":"","body":"Set集合(理解)Table of contentsSet集合的特点HashSet集合(掌握)TreeSet集合案例Set集合(理解) Table of contents Set集合(理解)Table of contentsSet集合的特点HashSet集合(掌握)TreeSet集合案例 Set集合的特点 无序,唯一 HashSet集合(掌握) 底层数据结构是哈希表(是一个元素为链表的数组) 哈希表底层依赖两个方法：hashCode()和equals() 执行顺序： 首先比较哈希值是否相同 相同：继续执行equals()方法 返回true：元素重复了，不添加 返回false：直接把元素添加到集合 不同：就直接把元素添加到集合 如何保证元素唯一性的呢? - 由hashCode()和equals()保证的 开发的时候，代码非常的简单，自动生成即可。 HashSet存储字符串并遍历 HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素) TreeSet集合 底层数据结构是红黑树(是一个自平衡的二叉树) 保证元素的排序方式 自然排序(元素具备比较性) 让元素所属的类实现Comparable接口 比较器排序(集合具备比较性) 让集合构造方法接收Comparator的实现类对象 把我们讲过的代码看一遍即可 案例 获取无重复的随机数 键盘录入学生按照总分从高到底输出 "},"04-Spring/":{"url":"04-Spring/","title":"Spring","keywords":"","body":"SpringSpring 使用POJO进行轻量级和最小侵入式开发 通过依赖注入和基于接口编程实现松耦合 通过AOP和默认习惯进行声明式编程 使用AOP和模板(template)减少模式化代码 "},"04-Spring/IntelliJ IDEA使用.html":{"url":"04-Spring/IntelliJ IDEA使用.html","title":"IntelliJ IDEA使用","keywords":"","body":"IntelliJ IDEAIntelliJ IDEA IntelliJ IDEA 打包 Spring Boot 项目为 jar 包 "},"04-Spring/Swagger2构建RESTful API.html":{"url":"04-Spring/Swagger2构建RESTful API.html","title":"Swagger2构建RESTful API","keywords":"","body":"Swagger2构建RESTful APISwagger2构建RESTful API "},"04-Spring/tmp.html":{"url":"04-Spring/tmp.html","title":"tmp","keywords":"","body":"tmpTable of contents定制Banner修改默认Banner关闭Bannertmp Table of contents tmpTable of contents定制Banner修改默认Banner关闭Banner 定制Banner 修改默认Banner Spring Boot启动的时候有一个默认的启团 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.9.RELEASE) src/main/resources 下新建 banner.txt 通过如下网站生成字符 http://patorjk.com/software/taag 复制写入 banner.txt 文件, 启动之后, 图案就会变成设定的图案. 关闭Banner "},"04-Spring/使用Spring访问mysql.html":{"url":"04-Spring/使用Spring访问mysql.html","title":"使用Spring访问mysql","keywords":"","body":"访问mysqlTable of contents前提创建数据库创建application.properties文件创建 @Entity 模型创建repository创建controller打包测试应用访问mysql 参考地址 GitHub 项目地址 Table of contents 访问mysqlTable of contents前提创建数据库创建application.properties文件创建 @Entity 模型创建repository创建controller打包测试应用 前提 JDK 1.8或更高 Gradle 2.3+ or Maven 3.0+ IDE 将项目下initial导入到IntelliJ IDEA git clone https://github.com/spring-guides/gs-accessing-data-mysql.git cd into gs-accessing-data-mysql/initial 创建数据库 mysql> create database db_example; -- 创建用户 mysql> create user 'springuser'@'localhost' identified by '111111'; -- 授权, 后期根据需求授权 mysql> grant all on db_example.* to 'springuser'@'%'; 创建application.properties文件 Spring Boot默认使用H2数据库, 所以我们需要更改为mysql, 并定义数据库相关设置. 创建文件 src/main/resources/application.properties spring.jpa.hibernate.ddl-auto=create spring.datasource.url=jdbc:mysql://localhost:3306/db_example?verifyServerCertificate=false&useSSL=false&requireSSL=false spring.datasource.username=springuser spring.datasource.password=111111 spring.jpa.hibernate.ddl-auto选项 spring.jpa.hibernate.ddl-auto可以设置为none, update, create, create-drop, 具体说明查阅Hibernate文档 none 使用 MySQL 数据库时, 默认值为 none, 不更改数据库结构. update Hibernate会根据给予的实体结构更改数据库. create 每次都创建数据库, 关闭的时候不会删除数据库. create-drop 创建并且在 SessionFactory 关闭的时候删除数据库. 这里使用create, 因为我们还没有创建表结构, 运行一次之后, 需要根据程序把spring.jpa.hibernate.ddl-auto设置为update或none, 当你想修改表结构的时候, 使用update. Spring为 H2或者其他嵌入的数据库使用的是 create-drop, 其他的为none, 比如 MySQL 生产中, 推荐把该参数设置为none, 并且回收用户权限, 给与SELECT, UPDATE, INSERT, DELETE权限即可. 创建 @Entity 模型 src/main/java/hello/User.java package hello; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; private String name; private String email; public Integer getId(){ return id; } public void setId(Integer id){ this.id = id; } public String getName(){ return name; } public void setName(String name){ this.name = name; } public String getEmail(){ return email; } public void setEmail(String email){ this.email = email; } } 实例类, Hibernate将自动转换成表结构. 创建repository src/main/java/hello/UserRepository.java package hello; import org.springframework.data.repository.CrudRepository; import hello.User; // CRUD refers Create, Read, Update, Delete public interface UserRepository extends CrudRepository { } repository接口, this will be automatically implemented by Spring in a bean with the same name with changing case The bean name will be userRepository 创建controller src/main/java/hello/MainController.java package hello; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.*; import hello.User; import hello.UserRepository; @Controller // 表明该类为 Controller @RequestMapping(path=\"/demo\") // url为 /demo public class MainController { @Autowired private UserRepository userRepository; @GetMapping(path=\"/add\") public @ResponseBody String addNewUser(@RequestParam String name , @RequestParam String email){ User n = new User(); n.setName(name); n.setEmail(email); userRepository.save(n); return \"Saved\"; } @GetMapping(path = \"/all\") public @ResponseBody Iterable getAllUsers(){ return userRepository.findAll(); } } 上述示例没有明确指定 GET,PUT,POST等等, 因为 @GetMapping 是一个快捷方式 @RequestMapping(method=GET). @RequestMapping方法默认映射所有HTTP方法. 使用@RequestMapping(method=GET) 或其他方法缩小映射. 打包 Although it is possible to package this service as a traditional WAR file for deployment to an external application server, the simpler approach demonstrated below creates a standalone application. You package everything in a single, executable JAR file, driven by a good old Java main() method. Along the way, you use Spring’s support for embedding the Tomcat servlet container as the HTTP runtime, instead of deploying to an external instance. src/main/java/hello/Application.java package hello; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Application { public static void main(String [] args){ SpringApplication.run(Application.class, args); } } 打成JAR包 你可以在命令行使用 Gradle 或 Maven. 或者你可以构建成一个包含所有依赖, 类, 资源文件的JAR包, 然后运行. 这会便于传输, 版本显示, 以及将服务部署成一个应用, 贯穿整个开发周期, 部署在不同的环境等等. 如果你在使用Gradle, 你可以通过运行./gradlew bootRun 来运行. 或者你可以使用 ./gradlew build 构建JAR包 . 然后使用如下命令运行jar包: java -jar build/libs/gs-accessing-data-mysql-0.1.0.jar 如果你使用Maven, 你可以使用 ./mvnw spring-boot:run 运行应用. 或者使用 ./mvnw clean package 打包, 运行: java -jar target/gs-accessing-data-mysql-0.1.0.jar 上面的步骤可以创建一个可执行的JAR包. 你也可以构建传统的 WAR 包. 运行过程中国会打印日志, 服务会在几秒钟后启动. 测试应用 使用 curl 或者浏览器测试. 现在有2个 REST Web Services localhost:8080/demo/all This gets all data localhost:8080/demo/add This adds one user to the data curl 'localhost:8080/demo/add?name=First&email=someemail@someemailprovider.com' 会得到如下回应 Saved curl 'localhost:8080/demo/all' 会得到如下回应 [{\"id\":1,\"name\":\"First\",\"email\":\"someemail@someemailprovider.com\"}] "},"04-Spring/异常处理.html":{"url":"04-Spring/异常处理.html","title":"异常处理","keywords":"","body":"异常处理异常处理 http://www.jianshu.com/p/12e1a752974d 使用加强Controller做全局异常处理。 "},"04-Spring/模板引擎.html":{"url":"04-Spring/模板引擎.html","title":"模板引擎","keywords":"","body":"模板引擎Table of contents静态资源访问模板Thymeleaf模板引擎 Table of contents 模板引擎Table of contents静态资源访问模板Thymeleaf 静态资源访问 Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则： /static /public /resources /META-INF/resources 我们可以在src/main/resources/目录下创建static，在该位置放置一个图片文件。启动程序后，尝试访问http://localhost:8080/xxx.jpg。如能显示图片，配置成功。 模板 Spring Boot提供了默认配置的模板引擎主要有以下几种： Thymeleaf FreeMarker Velocity Groovy Mustache 上述模板引擎中的任何一个，它们默认的模板配置路径为：src/main/resources/templates。路径可修改 Thymeleaf http://www.thymeleaf.org/ 示例 Name Price Oranges 0.99 Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 使用在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径src/main/resources/templates下编写模板文件即可完成。 org.springframework.boot spring-boot-starter-thymeleaf "},"04-Spring/注解.html":{"url":"04-Spring/注解.html","title":"注解","keywords":"","body":"注解注解 "},"05-lib/":{"url":"05-lib/","title":"lib","keywords":"","body":"liblib "},"05-lib/Lombok.html":{"url":"05-lib/Lombok.html","title":"Lombok","keywords":"","body":"LombokTable of contents@LogLombok Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again. Early access to future java features such as val, and much more. https://projectlombok.org/ https://github.com/rzwitserloot/lombok Table of contents LombokTable of contents@Log @Log 直接查看官方的概述 Overview "},"05-lib/SLF4J.html":{"url":"05-lib/SLF4J.html","title":"SLF4J","keywords":"","body":"SLF4JSLF4J https://www.slf4j.org/ "},"tmp.html":{"url":"tmp.html","title":"tmp","keywords":"","body":"tmpTable of contentsJava 正则tmp feign Table of contents tmpTable of contentsJava 正则 Java 正则 import java.util.regex.Pattern; import java.util.regex.Matcher; public static boolean isContainChinese(String str) { # 字符串里面是否有中文 Pattern p = Pattern.compile(\"[\\u4e00-\\u9fa5]\"); Matcher m = p.matcher(str); if (m.find()) { return true; } return false; } "},"测试题.html":{"url":"测试题.html","title":"测试题","keywords":"","body":"测试题Table of contentsfinal,finally,finalize的区别如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后测试题 Table of contents 测试题Table of contentsfinal,finally,finalize的区别如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后 final,finally,finalize的区别 如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后 会，前。 finally语句在try和catch语句中的return执行后、返回前执行； 若finally语句中没有return, 则其执行结果不影响try和catch中已确定的返回值; 若finally语句中有return，则其执行后的结果会直接返回。 "}}